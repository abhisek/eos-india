typedef struct tagPROFILE {
    DWORD   dwType;             // profile type
    PVOID   pProfileData;       // filename or buffer containing profile
    DWORD   cbDataSize;         // size of profile data
} PROFILE;

typedef PROFILE *PPROFILE, *LPPROFILE;

#define XOR_KEY1		0x49434D20

#define ERROR_OUT1				\
	do {						\
		SetLastError(0x57);		\
		return NULL;			\
	} while(0)

#define ERROR_OUT2				\
	do {						\
		SetLastError(0x08);		\
		return NULL;			\
	} while(0)	
	
#define ERROR_OUT3				\
	do {						\
		SetLastError(0x7DB);	\
		var_4 ^= XOR_KEY1;		\
		DWORD lv = GetLastError();	\
		do_cleanup(); /* not defined yet */		\
		return NULL;			\
	} while(0)	
	
	
DWORD sub_73B31D01(LPVOID arg0)
{
	LPVOID p;
	DWORD eax;
	DWORD ecx;
	DWORD y;
	
	y = *(DWORD*)((DWORD)arg0 + 0x20);
	if(*(DWORD*)((DWORD)arg0 + 0x20) < 0x80)
		return 0;
		
	p = *(LPVOID)((DWORD)arg0 + 0x24);
	eax = (DWORD) *p;
	arg0 = (DWORD) *p;
	
	eax = eax << 10; /* eax * 1024 */
	eax = (eax & 0x0FF00) || eax;
	
	ecx = 0;
	ecx = *((DWORD)p + 3);
	
	eax = eax << 8; /* eax * 256 */
	eax = eax | ecx;
	
	ecx = 0;
	ecx = *(UCHAR*)((DWORD)arg0 + 2);
	
	eax = eax | ecx;
	
	if(eax <= y) {
		
	}
}	
	
LPVOID sub_73B31FB5(DWORD dwBytes)
{
	LPVOID p;
	
	if(dwBytes <= 0)
		return NULL;
		
	p = GlobalAlloc(0x42, dwBytes) /* 0x42 = Combines GMEM_MOVEABLE and GMEM_ZEROINIT */
	p = GlobalLock(p);	/* Possible DoS while locking NULL? */
	
	return p;
}
	
DWORD sub_73B31D77(DWORD arg0)
{
	DWORD eax;
	LPVOID p;
	
	switch(arg0)
	{
		case 0x20434D4D:
			eax = 0x68;
			break;
		case 0x5052464C:
			eax = 0x28;
			break;
		case 0x5846524D:
			eax = 0x10;
			break;
		default:
			eax ^= eax;	/* eax = 0 */
			break;
	}
	
	p = sub_73B31FB5(eax);
	
	if(p == NULL)
		return NULL;
		
	*((DWORD*) p) = arg0;
	
	return (((DWORD) p) ^ XOR_KEY1);
}

/*
	MS08-046 patched function
*/
HPROFILE WINAPI OpenColorProfileW(
	PPROFILE 	lp,
	DWORD 		dwDesiredAccess,
	DWORD		dwShareMode,
	DWORD		dwCreationMode
)
{
	LPVOID		var_4;	/* [ebp - 4] */
	DWORD		var_8;	/* [ebp - 8] */
	
	if(!lp)
		ERROR_OUT1;
		
	if(IsBadReadPtr(lp, sizeof(PROFILE))
		ERROR_OUT1;
		
	if(lp->pProfileData != NULL) {
		if(IsBadReadPtr(lp->pProfileData, lp->cbDataSize))
			ERROR_OUT1;
	}
	
	if((lp->pProfileData == NULL) && (lp->cbDataSize != 0))
		ERROR_OUT1;
	
	if(!((lp->dwType == 1) || (lp->dwType == 2)))
		ERROR_OUT1;
		
	if(!((dwDesiredAccess == 1) || (dwDesiredAccess == 2)))
		ERROR_OUT1;
		
	var_4 = sub_73B31D77(0x5052464C);	/* Allocate 0x28 of memory from Global Heap */
	
	if(var_4 == NULL)
		ERROR_OUT2;
		
	var_4 ^= XOR_KEY1;	/* ebx = var_4 */
	*(DWORD*)((DWORD)var_4 + 0x04) = 1;
	*(DWORD*)((DWORD)var_4 + 0x08) = lp->dwType;
	*(DWORD*)((DWORD)var_4 + 0x10) = lp->cbDataSize;
	
	LPVOID p;	/* not actually defined in asm */
	p = sub_73B31FB5(lp->cbDataSize + 2);	/* Allocate and lock memory */
	*(DWORD*)((DWORD)var_4 + 0x0C) = (DWORD) p; /* Heap overflow while copying this data to a static allocated HEAP buffer later */
	
	if(p == NULL)
		ERROR_OUT2;
		
	/*
	Start: Changed code, apparently because of different compiler
	*/
	memcpy(p, lp->pProfileData, lp->cbDataSize);
	/*
	End: Changed code
	*/
	
	if(*(DWORD*)((DWORD)p + 0x08) == 1) {
		if(lp->pProfileData == NULL)
			ERROR_OUT1;
			
		if(lp->cbDataSize == 0)
			ERROR_OUT1;
			
		DWORD len;	/* actually not defined in asm */
		len = lstrlenW(lp->pProfileData);
		
		if(len > 0x104)
			ERROR_OUT1;
			
		if(lp->cbDataSize > 0x208)
			ERROR_OUT1;
		
		LPVOID p2;	/* not defined in real*/
		p2 = sub_73B319D4(*(DWORD*)((DWORD)var_4 + 0x0C));
		if(p2 == *(DWORD*)((DWORD)var_4 + 0x0C)) {
			/* TODO */
			/* Vuln path probably goes here */
			/* CODE FROM VULN DLL */
			LPVOID p3;
			p3 = sub_73B31FB5(0x104);
			
			lp = p3;
			if(p3 == NULL)
				SOME_ERROR_OUT;
				
			/* BAM BAM - Heap Overflow */
			GetColorDirectoryW(0, lp, &var_3);
			lstrcatW(lp, "\\");
			lstrcatW(lp, *(DWORD*)((DWORD)var_4 + 0x0C));
			
		}
		
		*(DWORD*)((DWORD)var_4 + 0x14) ||= 1;
		if(dwCreationMode == 4) {
			/* TODO */
		}
		
		SECURITY_ATTRIBUTES sa; /* not defined actually */
		DWORD da; /* not defined in real */
		HANDLE ha; /* not defined in real */
		
		sa.lpSecurityDescriptor = 0;
		sa.bInheritHandle;
		sa.nLength = 0x0C;
		
		da = 0;
		if(dwDesiredAccess == 2)
			da ||= 0x00000001;	/* setnz $al */
		da -= 1;
		da &= 0x40000000;
		da &= 0x80000000;
		
		
		ha = CreateFile(
			*(DWORD*)((DWORD)var_4 + 0x0C),
			da,
			dwShareMode,
			&sa,
			0x10000000,
			0
		);
		
		if(ha == INVALID_HANDLE)
			ERROR_OUTx;	/* not defined yet */
			
		*(DWORD*)((DWORD)var_4 + 0x18) = ha;
		
		if(GetFileSize(ha, 0) == 0) {
			/* TODO */
		}
		
		da = 0;
		if(dwDesiredAccess == 2)
			da ||= 0x00000001;
			
		CreateFileMapping(
			ha,
			NULL,
			da,
			0,
			GetFileSize(ha, 0),
			NULL
		);
		
	}
	else {
		if(lp->cbDataSize == 0) {
		}
		else {
			*(DWORD*)((DWORD)var_4 + 0x24) = *(DWORD*)((DWORD)var_4 + 0x0C); /*  = p */
			*(DWORD*)((DWORD)var_4 + 0x20) = *(DWORD*)((DWORD)var_4 + 0x10); /* = lp->cbDataSize */
			
			DWORD ret;	/* not defined in actual asm */
			ret = sub_73B31D01(var_4);
			
			if(ret == 0)
				ERROR_OUT3;
		}
	}
}